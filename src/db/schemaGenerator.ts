/**
 * Database schema generator: renders starter models and migrations
 * for different languages and ORMs.
 */

export interface SchemaModel {
  entities: EntityDefinition[];
  notes?: string;
}

export interface EntityDefinition {
  name: string;
  fields: Field[];
  description?: string;
}

export interface Field {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'date' | 'text' | 'json' | 'uuid';
  required?: boolean;
  unique?: boolean;
  primary?: boolean;
  reference?: string;
}

/**
 * Generate starter schema artifacts for a given database and language.
 * Returns a map of file paths to content.
 */
export async function generateSchema(
  database: string | undefined,
  language: string | undefined,
  schemaModel?: SchemaModel
): Promise<Record<string, string>> {
  const result: Record<string, string> = {};

  if (!database) return result;

  const entities = schemaModel?.entities || createDefaultEntities(database);

  switch (database.toLowerCase()) {
    case 'postgresql':
    case 'postgres':
      result['migrations/001_init.sql'] = renderPostgresSQL(entities);
      if (language === 'node' || !language) {
        result['prisma/schema.prisma'] = renderPrismaSchema(entities);
      }
      break;

    case 'mysql':
      result['migrations/001_init.sql'] = renderMySQLSchema(entities);
      if (language === 'node' || !language) {
        result['prisma/schema.prisma'] = renderPrismaSchema(entities);
      }
      break;

    case 'sqlite':
      result['migrations/001_init.sql'] = renderSQLiteSchema(entities);
      break;

    case 'mongodb':
    case 'mongo':
      if (language === 'node' || !language) {
        result['models/index.ts'] = renderMongooseModels(entities);
      } else if (language === 'python') {
        result['models.py'] = renderMongodbPythonModels(entities);
      }
      break;

    default:
      // Fallback to generic SQL
      result['migrations/001_init.sql'] = renderGenericSQL(entities);
  }

  return result;
}

function createDefaultEntities(database: string): EntityDefinition[] {
  return [
    {
      name: 'User',
      fields: [
        { name: 'id', type: 'uuid', primary: true },
        { name: 'email', type: 'string', required: true, unique: true },
        { name: 'name', type: 'string', required: true },
        { name: 'createdAt', type: 'date', required: true },
        { name: 'updatedAt', type: 'date', required: true }
      ]
    },
    {
      name: 'Session',
      fields: [
        { name: 'id', type: 'uuid', primary: true },
        { name: 'userId', type: 'uuid', required: true, reference: 'User' },
        { name: 'token', type: 'string', required: true, unique: true },
        { name: 'expiresAt', type: 'date', required: true },
        { name: 'createdAt', type: 'date', required: true }
      ]
    }
  ];
}

function renderPostgresSQL(entities: EntityDefinition[]): string {
  const tables = entities
    .map((entity) => {
      const cols = entity.fields
        .map((field) => {
          let colDef = `${field.name} ${postgresType(field.type)}`;
          if (field.primary) colDef += ' PRIMARY KEY';
          else if (field.required) colDef += ' NOT NULL';
          if (field.unique) colDef += ' UNIQUE';
          return colDef;
        })
        .join(',\n  ');
      return `CREATE TABLE ${entity.name.toLowerCase()} (\n  ${cols}\n);\n`;
    })
    .join('\n');

  return `-- Initial schema
-- Generated by idea2repo

${tables}`;
}

function renderMySQLSchema(entities: EntityDefinition[]): string {
  const tables = entities
    .map((entity) => {
      const cols = entity.fields
        .map((field) => {
          let colDef = `${field.name} ${mysqlType(field.type)}`;
          if (field.primary) colDef += ' PRIMARY KEY AUTO_INCREMENT';
          else if (field.required) colDef += ' NOT NULL';
          if (field.unique) colDef += ' UNIQUE';
          return colDef;
        })
        .join(',\n  ');
      return `CREATE TABLE ${entity.name.toLowerCase()} (\n  ${cols}\n);\n`;
    })
    .join('\n');

  return `-- MySQL schema
-- Generated by idea2repo

${tables}`;
}

function renderSQLiteSchema(entities: EntityDefinition[]): string {
  const tables = entities
    .map((entity) => {
      const cols = entity.fields
        .map((field) => {
          let colDef = `${field.name} ${sqliteType(field.type)}`;
          if (field.primary) colDef += ' PRIMARY KEY';
          else if (field.required) colDef += ' NOT NULL';
          if (field.unique) colDef += ' UNIQUE';
          return colDef;
        })
        .join(',\n  ');
      return `CREATE TABLE ${entity.name.toLowerCase()} (\n  ${cols}\n);\n`;
    })
    .join('\n');

  return `-- SQLite schema
-- Generated by idea2repo

${tables}`;
}

function renderGenericSQL(entities: EntityDefinition[]): string {
  const tables = entities
    .map((entity) => {
      const cols = entity.fields
        .map((field) => {
          let colDef = `${field.name} ${genericSQLType(field.type)}`;
          if (field.primary) colDef += ' PRIMARY KEY';
          else if (field.required) colDef += ' NOT NULL';
          if (field.unique) colDef += ' UNIQUE';
          return colDef;
        })
        .join(',\n  ');
      return `CREATE TABLE ${entity.name.toLowerCase()} (\n  ${cols}\n);\n`;
    })
    .join('\n');

  return `-- Database schema
-- Generated by idea2repo

${tables}`;
}

function renderPrismaSchema(entities: EntityDefinition[]): string {
  const models = entities
    .map((entity) => {
      const fields = entity.fields
        .map((field) => {
          let prismaType = prismaFieldType(field.type);
          let attrs = [];
          if (field.primary) attrs.push('@id');
          if (field.unique) attrs.push('@unique');
          if (field.reference) attrs.push(`@relation(fields: [${field.name}], references: [id])`);
          const attrStr = attrs.length > 0 ? ' ' + attrs.join(' ') : '';
          return `  ${field.name} ${prismaType}${field.required ? '' : '?'}${attrStr}`;
        })
        .join('\n');
      return `model ${entity.name} {\n${fields}\n}\n`;
    })
    .join('\n');

  return `// prisma/schema.prisma
// Generated by idea2repo

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

${models}`;
}

function renderMongooseModels(entities: EntityDefinition[]): string {
  const imports =
    "import { Schema, model, Document } from 'mongoose';\n\ninterface IDocument extends Document {}";
  const schemas = entities
    .map((entity) => {
      const schemaFields = entity.fields
        .map((field) => {
          const mongoType = mongooseFieldType(field.type);
          let fieldDef = `  ${field.name}: { type: ${mongoType}${field.required ? ', required: true' : ''}${field.unique ? ', unique: true' : ''} }`;
          return fieldDef;
        })
        .join(',\n');
      return `const ${entity.name}Schema = new Schema({
${schemaFields}
});

export const ${entity.name} = model<IDocument>('${entity.name}', ${entity.name}Schema);`;
    })
    .join('\n\n');

  return `${imports}\n\n${schemas}`;
}

function renderMongodbPythonModels(entities: EntityDefinition[]): string {
  const imports = "from mongoengine import Document, StringField, DateTimeField, UUIDField\nfrom datetime import datetime\n";
  const models = entities
    .map((entity) => {
      const fields = entity.fields
        .map((field) => {
          const pythonType = mongoEngineFieldType(field.type);
          const required = `required=${field.required || false}`;
          return `    ${field.name} = ${pythonType}(${required})`;
        })
        .join('\n');
      return `class ${entity.name}(Document):\n${fields}\n    meta = {'collection': '${entity.name.toLowerCase()}'}`;
    })
    .join('\n\n');

  return `${imports}\n${models}`;
}

// Type converters
function postgresType(type: string): string {
  const map: Record<string, string> = {
    string: 'VARCHAR(255)',
    number: 'INTEGER',
    boolean: 'BOOLEAN',
    date: 'TIMESTAMP',
    text: 'TEXT',
    json: 'JSONB',
    uuid: 'UUID'
  };
  return map[type] || 'VARCHAR(255)';
}

function mysqlType(type: string): string {
  const map: Record<string, string> = {
    string: 'VARCHAR(255)',
    number: 'INT',
    boolean: 'BOOLEAN',
    date: 'DATETIME',
    text: 'LONGTEXT',
    json: 'JSON',
    uuid: 'CHAR(36)'
  };
  return map[type] || 'VARCHAR(255)';
}

function sqliteType(type: string): string {
  const map: Record<string, string> = {
    string: 'TEXT',
    number: 'INTEGER',
    boolean: 'INTEGER',
    date: 'DATETIME',
    text: 'TEXT',
    json: 'TEXT',
    uuid: 'TEXT'
  };
  return map[type] || 'TEXT';
}

function genericSQLType(type: string): string {
  const map: Record<string, string> = {
    string: 'VARCHAR(255)',
    number: 'INT',
    boolean: 'BOOLEAN',
    date: 'TIMESTAMP',
    text: 'TEXT',
    json: 'TEXT',
    uuid: 'VARCHAR(36)'
  };
  return map[type] || 'VARCHAR(255)';
}

function prismaFieldType(type: string): string {
  const map: Record<string, string> = {
    string: 'String',
    number: 'Int',
    boolean: 'Boolean',
    date: 'DateTime @default(now())',
    text: 'String',
    json: 'Json',
    uuid: 'String @default(uuid())'
  };
  return map[type] || 'String';
}

function mongooseFieldType(type: string): string {
  const map: Record<string, string> = {
    string: 'String',
    number: 'Number',
    boolean: 'Boolean',
    date: 'Date @default(now())',
    text: 'String',
    json: 'Schema.Types.Mixed',
    uuid: 'String'
  };
  return map[type] || 'String';
}

function mongoEngineFieldType(type: string): string {
  const map: Record<string, string> = {
    string: 'StringField',
    number: 'IntField',
    boolean: 'BooleanField',
    date: 'DateTimeField',
    text: 'StringField',
    json: 'DictField',
    uuid: 'StringField'
  };
  return map[type] || 'StringField';
}
