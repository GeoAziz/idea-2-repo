type TemplateContext = {
  name: string;
  idea: string;
  normalized: {
    problem: string;
    domain: string;
    region?: string;
    riskSensitivity: string;
    appType: string;
  };
  classification: {
    kind: string;
    complexity: string;
  };
  copilotInput: string;
  copilotOutput: string;
  decisions: Record<string, any>;
};

const json = (value: unknown) => JSON.stringify(value, null, 2);

export function contentFor(path: string, context: TemplateContext) {
  const { name, normalized, classification, copilotInput, copilotOutput } = context;

  switch (path) {
    case 'README.md':
      return `# ${name}

${normalized.problem}

## Overview
This repository was generated by **idea2repo**, a CLI that turns product ideas into structured repo scaffolds.

## Detected Profile
- **App type**: ${normalized.appType}
- **Domain**: ${normalized.domain}
- **Risk sensitivity**: ${normalized.riskSensitivity}
- **Complexity**: ${classification.complexity}

## Getting Started
\`\`\`bash
npm install
npm run build
npm run start
\`\`\`

## What’s Inside
- \`docs/architecture.md\`: Architecture rationale (generated from Copilot CLI)
- \`docs/roadmap.md\`: Phased plan to build the MVP
- \`docs/decisions.md\`: Decision log and tradeoffs
- \`TODO.md\`: Actionable tasks to start building

## Notes
This scaffold is opinionated and intended to be edited. Use it as a starting point.`;

    case '.gitignore':
      return `node_modules
dist
.env
.idea2repo`;

    case 'package.json':
      return json({
        name,
        version: '0.1.0',
        private: true,
        description: normalized.problem,
        scripts: {
          build: 'tsc -p tsconfig.json',
          start: 'node dist/index.js',
          dev: 'ts-node src/index.ts',
          test: 'jest --coverage'
        },
        dependencies: {},
        devDependencies: {
          typescript: '^5.1.6',
          'ts-node': '^10.9.1',
          jest: '^29.5.0',
          '@types/jest': '^29.5.0',
          '@types/node': '^18.16.0'
        }
      });

    case 'tsconfig.json':
      return json({
        compilerOptions: {
          target: 'ES2020',
          module: 'commonjs',
          rootDir: 'src',
          outDir: 'dist',
          esModuleInterop: true,
          strict: true
        },
        include: ['src']
      });

    case 'TODO.md':
      return `# TODO (MVP)

## Setup
- [ ] Review \`docs/architecture.md\` and validate the proposed stack
- [ ] Confirm scope for ${classification.complexity} MVP
- [ ] Identify the first user flow to implement

## Build
- [ ] Scaffold core modules for a ${classification.kind} app
- [ ] Implement data models and interfaces
- [ ] Add basic tests in \`tests/\`

## Iterate
- [ ] Gather feedback and refine requirements
- [ ] Review decision log in \`docs/decisions.md\``;

    case 'docs/architecture.md':
      return `# Architecture

## Copilot CLI Prompt
\`\`\`
${copilotInput}
\`\`\`

## Copilot CLI Response
\`\`\`
${copilotOutput}
\`\`\`

## Summary
- **App type**: ${normalized.appType}
- **Domain**: ${normalized.domain}
- **Risk sensitivity**: ${normalized.riskSensitivity}
- **Complexity**: ${classification.complexity}

## Notes
Use the Copilot rationale above to guide implementation decisions.`;

    case 'docs/roadmap.md':
      return `# Roadmap

## Phase 1 — MVP
- Implement core ${classification.kind} flow
- Establish data model and validation
- Add tests and usage docs

## Phase 2 — Growth
- Improve UX and resilience
- Add analytics and monitoring
- Extend integrations as needed

## Phase 3 — Scale
- Harden security and compliance
- Optimize performance and scalability
- Formalize contribution process`;

    case 'docs/decisions.md':
      return `# Decision Log

## Key Decisions
- **App type**: ${normalized.appType}
- **Domain**: ${normalized.domain}
- **Risk sensitivity**: ${normalized.riskSensitivity}
- **Complexity**: ${classification.complexity}

## Tradeoffs
Copilot CLI recommended the architecture above. Adjust based on team preferences and constraints.`;

    case 'tests/main.test.ts':
      return `test('placeholder', () => {\n  expect(true).toBe(true);\n});`;

    case 'src/index.ts':
      return `export function main() {\n  console.log('Hello from ${name}!');\n}\n\nmain();`;

    case 'src/main.ts':
      return `export function run() {\n  return 'start here';\n}\n\nrun();`;

    case 'src/cli.ts':
      return `export function run() {\n  console.log('CLI entrypoint for ${name}');\n}\n\nrun();`;

    case 'src/commands/help.ts':
      return `export function help() {\n  console.log('Available commands: help');\n}`;

    case 'src/server.ts':
      return `import http from 'http';\n\nconst server = http.createServer((_req, res) => {\n  res.writeHead(200, { 'Content-Type': 'application/json' });\n  res.end(JSON.stringify({ status: 'ok' }));\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on http://localhost:3000');\n});`;

    case 'src/routes.ts':
      return `export const routes = [{ method: 'GET', path: '/', handler: 'healthCheck' }];`;

    case 'src/controllers/index.ts':
      return `export function healthCheck() {\n  return { status: 'ok' };\n}`;

    case 'src/App.tsx':
      return `export default function App() {\n  return <main>Welcome to ${name}</main>;\n}\n`;

    case 'src/pages/index.tsx':
      return `export default function Home() {\n  return <div>Home page</div>;\n}\n`;

    case 'src/components/Header.tsx':
      return `export function Header() {\n  return <header>Header</header>;\n}\n`;

    default:
      return `// TODO: Implement ${path}`;
  }
}
